import path from 'path';
import chalk from 'chalk';
import { executeSynchronous, lowerCaseEquals } from '../utils';
import { findAutogenEntries } from '../autogenlist';
import { saveAutogeneratedSchemaRefs, SchemaConfiguration, schemaPostProcess } from '../generate';
import * as constants from '../constants';

async function getChangedSchemas(repoPath: string) {
    var git = require('nodegit-kit');
    const changedSchemas = [];
    const repo = await git.open(repoPath);
    const status = await git.status(repo);
    for (const stat of status) {
        if (path.basename(path.dirname(path.dirname(stat.path))) === 'schemas'
            && path.extname(stat.path) === '.json') {
            if (stat.status !== 'modified' && stat.status !== 'new') {
                throw new Error(`Undefined file status for '${stat.path}'.`);
            } else {
                changedSchemas.push(path.join(repoPath, stat.path));
            }
        }
    }
    return changedSchemas;
}

executeSynchronous(async () => {
    const basePath = process.argv[2];
    const autogenEntries = findAutogenEntries(basePath);
    if (autogenEntries.length === 0) {
        throw new Error(`No autogenlist Configuration for '${basePath}'`);
    }
    let changedSchemaPaths = [];
    try {
        changedSchemaPaths = await getChangedSchemas(constants.generatorRoot);
    } catch {
        throw new Error(`Find undefined file status under '${basePath}'`);
    }
    let schemaConfigs: SchemaConfiguration[] = [];
    for (const changedSchemaPath of changedSchemaPaths) {
        console.log('Processing changed schema file: ' + chalk.green(changedSchemaPath));
        const namespace = path.basename(changedSchemaPath.substring(0, changedSchemaPath.lastIndexOf(path.extname(changedSchemaPath))));
        const autogenEntriesSameNamespace = autogenEntries
        .filter(autogenEntry => lowerCaseEquals(autogenEntry.namespace, namespace));
        if (autogenEntriesSameNamespace.length === 0) {
            throw new Error(`No autogenEntry for '${changedSchemaPath}'`);
        }
        if (autogenEntriesSameNamespace.length > 1) {
            throw new Error(`Multiple autogenEntries for '${changedSchemaPath}'`);
        }
        const autogenlistConfig = autogenEntriesSameNamespace[0];
        const localSchemaConfig = await schemaPostProcess(changedSchemaPath, autogenlistConfig);
        schemaConfigs.push(localSchemaConfig);
    }
    await saveAutogeneratedSchemaRefs(schemaConfigs);
});
